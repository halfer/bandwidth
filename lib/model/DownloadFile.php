<?php

/**
 * Skeleton subclass for representing a row from the 'download_file' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.2 on:
 *
 * Sun Jun 19 18:55:17 2011
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model
 */
class DownloadFile extends BaseDownloadFile
{
	/**
	 * Sets the created datestamp for new objects
	 * 
	 * @param PropelPDO $con 
	 */
	public function save(PropelPDO $con = null)
	{
		if ($this->isNew())
		{
			$this->setCreatedAt(time());
		}

		parent::save($con);
	}
	
	/**
	 * Returns the associated group object, or failing that a default one
	 * 
	 * @todo Do we need to cache the result here, or does Propel already do that for us?
	 * 
	 * @return array Array of DownloadGroup objects
	 */
	public function getGroups()
	{
		// Use (array) to avoid PropelCollection thingy
		$groups = (array) DownloadGroupQuery::create()->
			joinFileGroup()->
			where('FileGroup.DownloadFileId = ?', $this->getId())->
			find();
		
		if (!$groups)
		{
			$groups = array(
				DownloadGroupQuery::create()->
					filterBySystemGroupType(DownloadGroupPeer::TYPE_FILE_DEFAULT)->
					findOne()
			);
		}
		
		// @todo Make this a NoGroupException so it can be detected properly
		if (!$groups)
		{
			throw new Exception('This file has no group');
		}
		
		return $groups;
	}

	/**
	 * Lists the bandwidth for each group against the limit, and returns false if a limit is exceeded
	 *
	 * Basic query:
	 *  
	 * SELECT group.id, SUM(log.byte_count), group.bandwidth_limit
	 * FROM log
	 * JOIN filegroup
	 * JOIN group
	 * WHERE file.id = this.id
	 *		AND group.bandwidth_limit IS NOT NULL
	 * GROUP BY group.id, group.bandwidth_limit
	 * 
	 * @return boolean 
	 */
	public function isWithinGroupBandwidthLimits()
	{
		$c = new Criteria();
		$c->
			clearSelectColumns()->
			addSelectColumn(DownloadGroupPeer::ID)->
			addSelectColumn('SUM(' . DownloadLogPeer::BYTE_COUNT . ') AS bandwidth_usage')->
			addSelectColumn(DownloadGroupPeer::BANDWIDTH_LIMIT)->
			addJoin(DownloadLogPeer::DOWNLOAD_FILE_ID, FileGroupPeer::DOWNLOAD_FILE_ID)->
			addJoin(FileGroupPeer::DOWNLOAD_GROUP_ID, DownloadGroupPeer::ID)->
			add(DownloadLogPeer::DOWNLOAD_FILE_ID, $this->getId())->
			add(DownloadGroupPeer::BANDWIDTH_LIMIT, null, Criteria::ISNOTNULL)->
			addGroupByColumn(DownloadGroupPeer::ID)->
			addGroupByColumn(DownloadGroupPeer::BANDWIDTH_LIMIT);
		$stmt = DownloadFilePeer::doSelectStmt($c);
		
		$isPermit = true;
		while ($row = $stmt->fetch(PDO::FETCH_ASSOC) && $isPermit)
		{
			$isPermit = ($row['bandwidth_usage'] < $row['bandwidth_limit']);
		}
		
		return $isPermit;
	}

	/**
	 * Lists the count usage for each group against the limit, and returns false if a limit is exceeded
	 * 
	 * Strategy same as isWithinGroupBandwidthLimits. Note that this query includes downloads that
	 * have not yet finished.
	 * 
	 * @todo Could this be merged into isWithinGroupBandwidthLimits, for optimisation?
	 * @return boolean 
	 */
	public function isWithinGroupCountLimits()
	{
		$c = new Criteria();
		$c->
			clearSelectColumns()->
			addSelectColumn(DownloadGroupPeer::ID)->
			addSelectColumn('COUNT(*) AS count_usage')->
			addSelectColumn(DownloadGroupPeer::COUNT_LIMIT)->
			addJoin(DownloadLogPeer::DOWNLOAD_FILE_ID, FileGroupPeer::DOWNLOAD_FILE_ID)->
			addJoin(FileGroupPeer::DOWNLOAD_GROUP_ID, DownloadGroupPeer::ID)->
			add(DownloadLogPeer::DOWNLOAD_FILE_ID, $this->getId())->
			add(DownloadGroupPeer::COUNT_LIMIT, null, Criteria::ISNOTNULL)->
			addGroupByColumn(DownloadGroupPeer::ID)->
			addGroupByColumn(DownloadGroupPeer::COUNT_LIMIT);
		$stmt = DownloadFilePeer::doSelectStmt($c);
		
		$isPermit = true;
		while ($row = $stmt->fetch(PDO::FETCH_ASSOC) && $isPermit)
		{
			$isPermit = ($row['count_usage'] < $row['count_limit']);
		}
		
		return $isPermit;
	}

	/**
	 * Lists the number of concurrent connections per group, and returns false if a limit is exceeded
	 * 
	 * @param string $ipAddress Optionally limit the call to this IP
	 * @return boolean 
	 */
	public function isWithinGroupConcurrencyLimits($ipAddress = null)
	{
		$c = new Criteria();
		$c->
			clearSelectColumns()->
			addSelectColumn(DownloadGroupPeer::ID)->
			addSelectColumn('COUNT(*) AS count_concurrent')->
			addSelectColumn('COUNT(' . DownloadGroupPeer::CONCURRENT_LIMIT_PER_IP . ') AS count_concurrent_by_ip')->
			addSelectColumn(DownloadGroupPeer::CONCURRENT_LIMIT)->
			addSelectColumn(DownloadGroupPeer::CONCURRENT_LIMIT_PER_IP)->
			addJoin(DownloadLogPeer::DOWNLOAD_FILE_ID, FileGroupPeer::DOWNLOAD_FILE_ID)->
			addJoin(FileGroupPeer::DOWNLOAD_GROUP_ID, DownloadGroupPeer::ID)->
			add(DownloadLogPeer::DOWNLOAD_FILE_ID, $this->getId())->
			addGroupByColumn(DownloadGroupPeer::ID)->
			addGroupByColumn(DownloadGroupPeer::CONCURRENT_LIMIT)->
			addGroupByColumn(DownloadGroupPeer::CONCURRENT_LIMIT_PER_IP);
		
		# Only include items where user is still connected
		$c->add(DownloadLogPeer::IS_ABORTED, null, Criteria::ISNULL);
		
		# Only list rows if one of the concurrent limits is live
		$critA = $c->getNewCriterion(DownloadGroupPeer::CONCURRENT_LIMIT, null, Criteria::ISNOTNULL);
		$critB = $c->getNewCriterion(DownloadGroupPeer::CONCURRENT_LIMIT_PER_IP, null, Criteria::ISNOTNULL);
		$critB->addAnd($c->getNewCriterion(DownloadLogPeer::IP, $ipAddress));
		$critA->addOr($critB);
		$c->add($critA);
		$stmt = DownloadFilePeer::doSelectStmt($c);
		
		$isPermit = true;
		while ($row = $stmt->fetch(PDO::FETCH_ASSOC) && $isPermit)
		{
			$isPermit = (
				($row['count_concurrent'] <= $row['concurrent_limit']) &&
				($row['count_concurrent_by_ip'] <= $row['concurrent_limit_by_ip'])
			);
echo "<pre>" . print_r($row, true) . "</pre>";
exit();
		}
		
		return $isPermit;
	}
}
